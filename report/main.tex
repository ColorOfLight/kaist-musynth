\documentclass{article}
\usepackage[utf8]{inputenc}

\title{\textsc{KaiSynth}: Program Synthesis via Code Reuse and Manipulation}
\author{Donghoon Han, Seokhyun Nam, Seongho Park, Tae Soo Kim\\Group 7}

\usepackage{graphicx}
\usepackage{biblatex}
\addbibresource{references.bib}

\begin{document}

\maketitle

\section{Introduction}
The advent of the Internet has facilitated the sharing of and the exploration of information. An immeasurable amount of knowledge is available at one's fingertips. The field of software development has flourished thanks to this. Individuals can easily make their programs or pieces of code available to others who can then exploit the easily accessible code to improve their own programs or accelerate their development process.

However, although the accessibility of what has been nicknamed as "Big Code" can assist developers, efficiently harnessing this vast pool of code can be a difficult task. Developers cannot simply copy and paste any code fragment found online into their own program. A suitable fragment must first be found then it has to be manually altered to fit into the program's context. Depending on the program's and fragment's complexity, this can be a time-consuming and tedious task for the developer. Despite it being tedious, this practice of code reuse is common among software developers 

In this paper, we propose and describe our system \textsc{KaiSynth} that can automatically synthesize programs by "filling" holes in a given program by utilizing and manipulating code fragments from other programs. Based on the system \textsc{MuSynth} \cite{musynth}, our approach uses a genetic algorithm that takes, as input, a draft program with an explicitly demarcated gap in the code. Such a gap could be present due to the developer's inability to code a functionality owed to their lack of expertise or time. \textsc{KaiSynth} generates a functional complete program by "filling" the hole with code fragments, extracted from a pool of similar programs, that have been slightly modified throughout evolutionary cycles. 

We present our evaluation of \textsc{KaiSynth} utilizing implementations of simple algorithms written by users on the website HackerRank \cite{hackerrank}. Results from the evaluation demonstrated that [description]. After presenting these results, we conclude the paper by examining the limitations of our work and possible future improvements that can be made to the system to allow for general usage.


\section{Background}
\subsection{\textsc{MuSynth} and Source Forager}
Our work is based on the system \textsc{MuSynth}. The authors of the paper constructed a system that, given a partial C program, could search through a large body of code to find similar programs, and then use fragments from these to complete the input partial program. They achieved this by utilizing their tool Source Forager \cite{sourceforager}, a similar-code-search engine they constructed prior \textsc{MuSynth}.

Our task was to replicate \textsc{MuSynth} with the guidance of the minimal specifications provided in the paper. \textsc{KaiSynth} differs with the original system in that it manipulates programs implemented in the Python programming language, instead of C, and uses manually populated code pools. Replicating the tool Source Forager would have been a demanding task outside of the scope of search-based software engineering.

\subsection{Abstract Syntax Trees}
\textsc{KaiSynth} manipulates and modifies programs by transforming them into abstract syntax trees (ASTs) utilizing the Python \texttt{ast} module \cite{astpython}. ASTs are tree representations of program code. Each node in the tree represents a constant value, a variable name, or an operation. The children of each node are the values on which an operation will be performed.  The \texttt{ast} module is a standard library in Python 3 that, given program code in string form, returns an AST representation of the code.


\section{\textsc{KaiSynth} Overview}

\textsc{KaiSynth} takes as input a program with a hole, test cases which will be utilized to evaluate the programs synthesized by the system, and a pre-populated code pool. In our system, a hole is represented by a single line of code that exclusively contains the variable name \texttt{\_\_HOLE\_\_}. This variable acts as a placeholder. The system will replace the line with fragments of code---composed of one or more lines---brought from the code pool. With these inputs, \textsc{KaiSynth} output a complete functional program through an evolutionary algorithm.

\subsection{Initial Set Up}

Before the system can initiate the evolutionary algorithm, it must perform preliminary processing of the programs in the code pool and the input program, the program with a hole. Initially, the AST representations of all the programs found in the code pool are obtained through the Python \texttt{ast} module. This set of ASTs are then utilized to construct two data structures which form the basis of the evolutionary algorithm: the code snippet list, and the function dictionary.

The code snippet list is a list that contains all the possible AST subtrees that can be extracted from the set of ASTs. Thus, each entry in the code snippet list is an AST subtree that represents a code fragment or snippet found in one of the programs in the code pool. The function dictionary is a list that contains all the functions that are defined within the programs found in the code pool. Each entry is keyed by the name of the function. Before the code snippet list and the function dictionary are constructed, for all functions defined in each program from the code pool, all instances of the function's name are suffixed with the name of the file the program is stored in. This precautionary step is taken to prevent overlapping between function names defined in the code snippets and function names defined in the input program.

To generate the initial population, \textsc{KaiSynth} transforms the input program with a hole to its AST representation. The hole will be represented by a node containing only the variable \texttt{\_\_HOLE\_\_}. 200 different AST subtrees are randomly selected from the code snippet list and are used to replace the \texttt{\_\_HOLE\_\_} node in the input program's AST. Using the rebind variable name mutation, several randomly selected variable names found within the code snippet subtrees are replaced with randomly selected variable names found in the input program's AST. This generates 200 candidate program ASTs that form the initial population for the evolutionary algorithm. Each of these individuals in the population is evaluated through the fitness function and assigned a fitness value.

// TODO: verify that the initial population is assigned fitness values

\subsection{Fitness Function}

// TODO: talk about the function dictionary when talking about transforming to program code

To evaluate the fitness of each individual in the population, the individual which is an AST is first transformed into program code. After the transformation, for any function call found in the AST subtree of the code snippet, the function name is used to extract the definition from the function dictionary and the definition is then appended to the beginning of the program code. This program code is then evaluated against the test cases provided as inputs to the system. Each test case is a pair of inputs to be provided to a synthesized program and expected outputs. Instead of evaluating each candidate program against all of the provided test cases, \textsc{KaiSynth} evaluates the candidate program through lexicase selection.

In lexicase selection, at every evolutionary cycle, the test cases are given a different random ordering. The candidate program is evaluated with the first test case in the ordering. The candidate program is executed with the inputs in the test case and the output given by the execution is compared to the expected output for the test case. If the given output and the expected output are equal, a counter incremented by 1 and the program is evaluated using the next test case. If the program returns an output different to the expected output, the counter is incremented by 0.5. This continues until the program faces a runtime error or exceeds the execution time limit. At this point, the system stops evaluating the program, divides the value stored in the counter by the total number of test cases, and assigns the result as the fitness value of the candidate program. 

\subsection{The Evolutionary Cycle}

In each cycle of the evolutionary algorithm, \textsc{KaiSynth} mutates each of the individuals in the population to create new individuals. The four possible types of mutations that can be applied on an individual are the refill mutation, the rebind variable name mutation, the replace variable with constant mutation, and the fix-off-by-one mutation. Further details on the operations performed by each mutation type will be provided in section 3.4. For each individual, only one mutation type is selected based on predefined probabilities and applied on the individual.

// TODO: verify the predefined probabilities for each mutation type and that only one is applied
// TODO: verify how the bottom half is determined and discarded

After the mutations are applied, each new individual is evaluated and assigned a fitness value. Among the individuals in the original population and the population generated through the mutations, the 200 individuals with the lowest fitness values are discarded. Only the top half, with respects to fitness values, from the combined population of original and mutated individuals survive to the next evolutionary cycle. The survivors then form the new, original population and are mutated to generate new individuals that are evaluated. This cycle of mutation, evaluation and selection continues until one of the individuals in the population passes all of the test cases correctly during its evaluation. If such an individual is synthesized, \textsc{KaiSynth} halts the evolutionary cycle and returns the code form of this individual as the final output program,

\subsection{The Four Mutations}

\textsc{KaiSynth} applies four different types of mutations that slightly modify the AST subtrees of the code snippets used to fill the hole to allow the snippet to fit into the context of the program it is filling. The first and most crucial of these mutations is the refill mutation. The refill mutation replaces the AST subtree of the code snippet used to fill the hole with a different, random AST subtree of a code snippet brought from the code snippet list.

// TODO: need to verify that only variable names not initialized in the hole are rebinded

The second mutation applied by the system is the rebind variable name mutation. During this mutation, a random variable name found in the original input program is selected. By walking through the AST subtree of the code snippet, a random variable name used in the code snippet is also selected. All instances of this variable name in the code snippet subtree are replaced with the variable name selected from the input program. 

The third mutation is the replace variable by constant mutation. In this mutation, the largest constant found in the input program's AST is selected by walking through the tree. Similar to the rebind variable name mutation, a random variable name found in the code snippet AST subtree is selected and all instances of this variable name in the subtree are replaced with the constant selected from the input program.

The final mutation is the fix off-by-one mutation. In this mutation, a random instance of a constant in the code snippet AST subtree is selected and it is replaced with a constant that has value which is one less than that constant. 


\section{Evaluation}
Our evaluation and comparison to random search.


\section{Limitations}
Limitations of the system we built. Mostly due to python.
Integers 


\section{Conclusion}
Our experience overall from this.

\printbibliography

\end{document}
